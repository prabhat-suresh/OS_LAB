[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13]=SP;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = -1;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

backup;

multipush(EIP);
if(EC!=0 || [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13]==[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 15]*512-1) then
	
	R1=EXIT_PROCESS;
	R2=[SYSTEM_STATUS_TABLE+1];
	call MOD_1;

	call SCHEDULER;
endif;

if(EPN==2 || EPN==3) then

	R1=GET_FREE_PAGE;
	R2=[SYSTEM_STATUS_TABLE+1];
	call MOD_2;
	[PTBR+4]=R0;
	[PTBR+5]="1110";

	R1=GET_FREE_PAGE;
	R2=[SYSTEM_STATUS_TABLE+1];
	call MOD_2;
	[PTBR+6]=R0;
	[PTBR+7]="1110";

else 		// EPN is between 4 and 7
	R1=GET_CODE_PAGE;
	R2=[DISK_MAP_TABLE+10*[SYSTEM_STATUS_TABLE+1]+EPN];
	call MOD_2;
	[PTBR+2*EPN]=R0;
	[PTBR+2*EPN+1]="1100";

endif;

multipop(EIP);
restore;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;

SP=[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13];
SP=SP+1;
[[PTBR+2*(SP/512)]*512+SP%512]=EIP;
ireturn;
